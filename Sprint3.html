<!DOCTYPE html>
<html>
<head>
    <title>Meine Seite</title>
    <style>
        body {
            background-color: #FFC0CB;
        }

        .sprint-heading {
            font-size: 28px;
            color: #333;
            font-weight: bold;
            text-transform: uppercase;
            text-align: center;
        }
    </style>
</head>
<body>
    <h2 class="sprint-heading">Sprint 3</h2>

    <br>
    <br>

<p> Task1 <br>
    
a)
Map Editor:<br>
We improved our map editor greatly, the different tiles can be drawn on the screen directly.<br>
Through pushing a "save" - button a text file is created, which can be used to create the playable arena.<br>
    
    

class MapEditor:<br>
We use a grid-layout which arranges widgets in a grid-like structure.<br>
Clicked.connect function: When the water_button is clicked, a clicked signal is emitted, and the slot function, 
which is the set_draw_mode method is executed.<br>
Without lambda, the slot function would be immediately called without waiting for the button to be clicked.<br>
The return value of self.set.draw_mode() would be passed to, which is none. It ensures that the past argument 
remains a function.<br> 



    
The "save" button:<br>

    
    
Difficulty:<br>
Since we are using a grid-layout, the widgets are automatically aligned to a certain extent based on the layouts grid structure.<br>
This made it difficult to position the buttons in a desireable way.<br>
For example, the following code had no effect:<br>
    

We helped us, by adding an empty stretch which pushes the buttons at the bottom of the screen.<br>
   
    
Further improvement:<br>
Instead of just coloring the tiles, we want to create the playable arena by letting the user draw our graphical tiles on the screen.<br>
A backtrack option to reset the latest drawing would be useful.<br>

    
    
b)

c)
We changed the Robots from directly using a movement Speed variable to determine their speed to now calculate their current velocity using acceleration and the time between "frames".<br>
The same thing was done to the calculation of rotational speed.<br>

To avoid reaching infinite speeds we also introduced constants for maximum movement speed and maximum rotational speed.<br>
This is where we deviate a little from the original Task and instead of a programm wide constant introduce a different constant for every "type" of robot. This will allow us to have more or less agile types of robots in the future.<br>
Furthermore we did not clamp the robots aceleration but instead it's speed.
Implementation of speed and aceleration: <br>
<img src="assets/Sprint3/AccelerationCalculation.png"><br>

<p>You can see the Robots moving here: <br>

 <video width="960" height="720" controls src="assets/Sprint3/RobotsSimpleMove.mp4" type=""assets/Sprint3/RobotsSimpleMove.mp4"/>
  Your browser does not support the video tag.
</video>
<br>
d)
For threads we use a worker class that inherits from QThread.<br>
The MovementManager_ is a class that handles the movement wenn we start the thread we create an object of that class.<br>
The moveRobot function gets called using a signal it uses the Movement Manager to update the Position.<br>                                                                                                                               
<img src="assets/Sprint3/workerClass.png"><br>
Some Problems here since we also tried QThreadpool it would be easier to run multiple Threads but since it does not support signals and slots we choose the Qthread.<br>
The signal and a dictionary to store the threads.<br>
<img src="assets/Sprint3/SignalForWorker.png"><br>
This Function creates the threads and starts them:<br>
<img src="assets/Sprint3/RunThreads.png"><br>
The first for loop creates the threads and puts them in the dictionary.<br>
The second one  connects the signals and starts the threads.<br>

<p> Task2 <br>
For now we only drew 4 different tiles: Grass, Fire, Water and Wall tiles <br>
These were drawn by hand using an online Pixel art editor <br>
  <img src="assets/Sprint3/Grass_tile.png">
  <img src="assets/Sprint3/Fire_tile.png">
  <img src="assets/Sprint3/Water_tile.png">
  <img src="assets/Sprint3/Wall_tile.png">
<br>

We are not yet using these to draw the arena.

</body>
</html>
