<!DOCTYPE html>
<html>
<head>
    <title>Sprint 4</title>
    <style>
        body {
            background-color: #D3D3D3;
            font-family: Arial, sans-serif;
        }

        .sprint-heading {
            font-size: 50px;
            color: #333;
            font-weight: bold;
            text-transform: uppercase;
            text-align: center;
        }
    </style>
</head>
<body>
    <h2 class="sprint-heading">Sprint 5</h2>

    

        <p><strong><span style="font-size: larger;">Improving and extending menu structure (Nico) </span></strong> <br><br>

        Included new menu pages and extended the options menu to allow the player to control the volume of the game music.<br><br>
            
        Following a short video to demonstrate the menu structure and the playing background sound. <br>    
        <video width="1000" height="720" controls>
  <source src="Sprint5/Menu_Sound_Video.mp4" type="video/mp4">
</video> <br>
            
         <br>To ensure that the menu windows always have the same starting position, we pass the positions of the currently displayed menu window to the upcoming window.<br>
        <img src="Sprint5/coordinates.JPG" alt="Italian Trulli"> <br><br>
   
    
        <p><strong><span style="font-size: larger;">Including background sound</span></strong> <br><br>
        
        We work with a config file to save changes made in the options menu. <br>
            
        <img src="Sprint5/config file.JPG" alt="Italian Trulli"> <br>
            
        Changing values in the options menu will overwrite the entries in the config file.<br>

            <img src="Sprint5/slider_value_changed.JPG" alt="Italian Trulli"> <br>
            
        It ensures that changes made will remain even if you quit and restart the game. <br>
        Currently our only entries are regarding the game sound. <br>
        A possible stretch goal could be to provide players with the ability to modify the game controls through the options menu and save the changes in the config file.<br>

        To play the music we implemented a class MusicPlayer:<br>
        
        <img src="Sprint5/class musicplayer.JPG" alt="Italian Trulli"> <br>    


        With following functions:<br>
        <img src="Sprint5/functionsmusicplayer.JPG" alt="Italian Trulli"> <br>

        Restart_playback causes the music to run in a loop. <br>
        The update_music function is called every 500 milliseconds and adjusts the volume of the music based on the value specified in the config file.<br><br>

        <b>Difficulties</b><br>
        Actually Finding an implementation where the music is played independently by the actions of the player in the main menu. <br> 
        In previous versions the music didnt loop or got restarted every time a window(menu) is switched. <br>
        Among others we tried to use threads to play the music which didnt end up working.  <br><br>
   
        <p><strong><span style="font-size: larger;">Improving Map Editor and including it in the menu structure</span></strong> <br><br>

        Remade the UI of the mapeditor with qtdesigner. <br>
        Put the buttons in an non-drawable area to the right. Beforehand they were in the midst of the screen<br>

        Implemented load function to convert an already saved txt.file back to a drawn arena. <br>

        <img src="Sprint5/LoadMap.JPG" alt="Italian Trulli"> <br><br>

        Video that showcases the load function and the new UI of the MapEditor:<br>
        <video width="1000" height="720" controls>
  <source src="Sprint5/mapload.mp4" type="video/mp4">
</video> <br><br><br>
            
            
        <b>Problem:</b><br>
        Circular dependency between the Menus.py and MapEditor.py file. Solved with following code line: <br>
        <img src="Sprint5/command_circular_dependency.JPG" alt="Italian Trulli"> <br>
        MapEditor only gets imported, when we actually switch to the MapEditor window.<br><br><br><br><br><br>


        <p><strong><span style="font-size: larger;">Adding Health and Weapons (Marcel John) </span></strong> <br><br>
        
        added maxHealth and health as ints<br>
        added function to heal and deal demage<br>
        <img src="Sprint5/healingAndDamage.png"><br>
        Weapons are objects we use enums to differentiate<br>
        <img src="Sprint5/weaponEnum.png"><br>
        The Weapon stores the attributes<br>
        <img src="Sprint5/weaponClass.png"><br>
        The inputHandler shoots the Weapon, also added a delay between shoots<br>
        <img src="Sprint5/shootInput.png"><br>
        For the drawing added helper functions to calculate the position of the health bar and the end point of the shoot<br>
        <img src="Sprint5/helperfuncForHealthAndShoot.png"><br>
        Drawing the healthbar and shoot<br>
        <img src="Sprint5/DrawHealthbarAndShoot.png"><br>
        <img src="Sprint5/inGameHealthbar.png"><br><br>
        To calculate if we hit we use vector Math<br>
        we treat our shot as a line a vector ab and the robot we are checking<br>
        to ac from end shot to center of robot we calculate the length. Using the length we normalize the vector ab<br>
        to get the direction. We get the distance using the dotproduct of the normalazied vector and ac.<br>
        The distace on line function enshures the closest point is on the line.<br>
        Now we make the Projection vector using distance and the direction.<br>
        Using this vector we can find the closest point on the line to our circle.<br>
        Now we only need to cheeck if the closest point is closer than the raidius than we apply the damage.<br>
        <img src="Sprint5/DamagecalcPart1.png"><br>
        <img src="Sprint5/DamagecalcPart2.png"><br>
        <img src="Sprint5/DamagecalcPart3.png"><br>
        <img src="Sprint5/DamagecalcPart4.png"><br>



        <p><strong><span style="font-size: larger;">Adding Robot to Robot Collision detection (Tom) </span></strong> <br><br>
        Since we don't want our robots to be able to drive through each other we extended our previous collision detection function to also take other robots into account.<br>
        We do this by giving each robot an array which conatins all other robots currently alive in the arena. <br>
        <img src="Sprint5/UpdateRobotRobotArray.png"><br>

        And then iterating over all other robots to check if we are intersecting with any of them. Since all of our robots will be of circular shape this is quite inexpensive.<br>
        <img src="Sprint5/RobotRobotCollFunc.png"><br>


        <p><strong><span style="font-size: larger;">Adding Tile Logic to our Game (Tom) </span></strong> <br><br>
        In our Game we have differnet kinds of Terrain, such as Fire, Water, Spikes and more. Each of these should have a specific effect on the players whenever they drive over them. <br>
        At first our robots were much bigger than our Tiles, meaning at any point the robot would be on multiple tiles at a time, so we opted to apply every effect of every Tile the Robot was currently on.<br>
        This was a bad Idea since its very hard to see which tiles you are actually on and the sum of all the effects can be quite overwhelming and even cancel eachother out, leading to very confusing behaviour.<br>
        We have since adjusted our Robots to be much smaller than the tiles, now we only ever apply the effect of one Tile!<br>

        <br>Size of a Robot next to a Tile:<br>

        <img src="Sprint5/RobotTileComparison.png"><br>

        This had the nice side effects of making our collision detection faster since there are less tiles to check for collision and our reading of the Arena Text file has also gotten faster since it is smaller now.<br>


        How we apply effects of each Tile type currently:<br>
        <img src="Sprint5/TileLogicFunc.png"><br>

        The Move multiplier as seen above is then multiplied with our speed in the move function, resulting in slower or faster movement.<br>
        <img src="Sprint5/MoveMultInFunc.png"><br>



</body>
</html>
